// Autoren: Friederike Richter und Moritz Raake
// Datum: 11.03.2020
// Zweck: Softwarepraktikum 2020

package spielfeld

import ("../gelaende";"../einheiten";"gfx" /*; "../items"*/)

type data struct {
	x,y uint16						// Anzahl x- & y-Kästchen --> perspektivisch soll es variabel sein
	groesse uint16					// Pixelzahl Feldgröße --> perspektivisch soll es variabel sein
	dateiname string
	gelaendematrix [][]gelaende.Gelände	// 
	einheitenmatrix [][]einheiten.Einheit	
	//itemmatrix [][]items.Item		// --> später einzufügen....Optional je nach Spielentwicklung
}

func New (x,y,groesse uint16, dateiname string) *data {
	var neu *data = new(data)
	(*neu).gelaendematrix= make ([][]gelaende.Gelände,y)
	(*neu).einheitenmatrix=make ([][]einheiten.Einheit,y)
	(*neu).x= 20 // x --> später wenn variabel;
	(*neu).y= 12 // y --> später wenn variabel
	(*neu).groesse = 50 // groesse --> später wenn variabel
	(*neu).dateiname = dateiname
	for i:=uint16(0);i<y;i++ {
		var neuegelaendezeile []gelaende.Gelände = make([]gelaende.Gelände,x)
		(*neu).gelaendematrix[i]=neuegelaendezeile
	}
	for i:=uint16(0);i<y;i++ {
		var neueeinheitenzeile []einheiten.Einheit = make([]einheiten.Einheit,x)
		(*neu).einheitenmatrix[i]=neueeinheitenzeile
	}
	//(*neu).itemmatrix=make ([][]items.Item,y)	
	//for i:=0;i<y;i++ {
	//	var neueitemzeile []items.Item = make([]items.Item,x)
	//	(*neu).itemmatrix[i]=neueitemzeile
	//}																	// --> später einzufügen....Optional je nach Spielentwicklung
	return neu
}

	// Vor.: ---
	// Erg.: Ein Verweis auf das an dem übergebenen Koordinaten befindliche Gelände ist geliefert.	

func (s *data) GibGelände (x,y uint16) gelaende.Gelände {
	return (*s).gelaendematrix[y][x]
}

	// Vor.: ---
	// Eff.: Das übergebene Gelände befindet sich nun an den übergebenen Koordinaten. Das vorherig dort
	//		 befindliche Gelände ist entfernt.

func (s *data) SetzeGelände (x,y uint16, gelände gelaende.Gelände) {
	(*s).gelaendematrix[y][x]=gelände
}
	
	// Vor.: Das Geländefeld muss mit einer Einheit besetzt sein.
	// Erg.: Ein Verweis auf die auf dem übergebenen Geländefeld befindlichen Instanz ist geliefert.
func (s *data) GibEinheit (x,y uint16) einheiten.Einheit {
	if (*s).einheitenmatrix[y][x] == nil {
		panic ("Geländefeld nicht belegt")
	}
	return (*s).einheitenmatrix[y][x]
}
	
	// Vor.: Das Geländefeld mit den übergebenen Koordinaten darf nicht besetzt sein.
	// Eff.: Auf dem Geländefeld mit den übergebenen Koordinaten befindet sich nun die übergebene
	//		 Einheit. 
func (s *data) SetzeEinheit (x,y uint16, einh einheiten.Einheit) {
	if (*s).einheitenmatrix[y][x] == nil {	
		(*s).einheitenmatrix[y][x] = einh
		// Belegung des Geländefeldes muss auf 'true' geändert werden
		var gel gelaende.Gelände = gelaende.New (0,0,"Wasser")
		gel= (*s).gelaendematrix[y][x]
		gel.SetzeBelegung(true)
		(*s).gelaendematrix[y][x]=gel
	}
}
	
	// Vor.: Das Geländefeld mit den übergebenen Koordinaten muss mit einer Einheit besetzt sein.
	// Eff.: Die auf dem Geländefeld mit den übergebenen Koordinaten befindliche Einheit ist entfernt.
func (s *data) EntferneEinheit (x,y uint16) {
	if (*s).einheitenmatrix[y][x] != nil {
		(*s).einheitenmatrix[y][x] = nil
		// Belegung des Geländefeldes muss auf 'false' geändert werden
		var gel gelaende.Gelände = gelaende.New (0,0,"Wasser")
		gel= (*s).gelaendematrix[y][x]
		gel.SetzeBelegung(false)
		(*s).gelaendematrix[y][x]=gel	
	}
}
	
	/*GibItem (x,y uint16) items.Item
	
	SetzeItem (x,y uint16, item items.Item) 
		
	EntferneItem (x,y uint16) */
	
func (s *data) Zeichnen () {
	if !gfx.FensterOffen() {
		gfx.Fenster((*s).x*(*s).groesse+200,(*s).y*(*s).groesse+100) // --> variabel, falls entfernen breite:1200 und Höhe 700
	}
	// Zeichnen der Geländeschicht
	for _,gelreihe := range (*s).gelaendematrix {
		for _,gel := range gelreihe {
			gel.Zeichnen ()
		}
	}
	// Einzeichnen der Einheiten
	for _,einhreihe := range (*s).einheitenmatrix {
		for _,einh := range einhreihe {
			if einh != nil {
				einh.Zeichnen ()
			}
		}
	}
	/* Einzeichnen der Items
	 * for _,itmreihe := range itemmatrix {
		for _,itm := range itmreihe {
			if itm != nil {
				itm.Zeichnen ()
			}
		}
	} *///--> sofern Items hinzugefügt werden sollen 
	
	// Das Gitterraster wird darüber gezeichnet
	gfx.Stiftfarbe(0,0,0)
	// Vertikale Linien werden gezeichnet
	for i:=uint16(0);i<(*s).x;i++ {											// Gitter ebenfalls variabel gezeichnet
		gfx.Linie(i*(*s).groesse,0,i*(*s).groesse,(*s).y*(*s).groesse-1)	// ebd.
	}
	// Horizontale Linien werden gezeichnet
	for i:=uint16(0);i<(*s).y;i++ {											// ebd.
		gfx.Linie(0,i*(*s).groesse,(*s).x*(*s).groesse-1,i*(*s).groesse)	// ebd.
	}
}	
	
	// Vor.: ---
	// Erg.: Eine Folge von Bytes ist geliefert, die die aufrufende Instanz serialisiert darstellt.
func (s *data) Kodieren () (b []byte){
	b = make ([]byte,0)
	b = append(b,byte((*s).x/256),byte((*s).x%256))					// Kodieren der Y-Koordinaten ---> XXXX nur notwendig wenn variabel
	b = append(b,byte((*s).y/256),byte((*s).y%256)) 				// Kodieren der Y-Koordinaten ---> XXXX nur notwendig wenn variabel
	b = append(b,byte((*s).groesse/256),byte((*s).groesse%256)) 	// Kodieren der Größe---> XXXX nur notwendig wenn variabe
	var stringlaenge uint8
	// Kodieren der Anzahl an Bytes des Strings
	stringlaenge=uint8(len((*s).dateiname))					
	b = append(b,stringlaenge)
	// Kodieren des Dateinamens
	for _,w := range (*s).dateiname {								
		b = append(b,byte(w))
	}
	// Kodieren der Geländematrix
	for _,w := range (*s).gelaendematrix {						
		for _,gel := range w {
			// Kodieren des Geländes als []byte ...
			var gelaendebytes []byte = make([]byte,0)
			gelaendebytes = gel.Kodieren()
			// Kodieren und anhaengen der Anzahl an Bytes des Geländes
			var gelaendegroesse uint16 = uint16(len(gelaendebytes))
			b = append(b,byte(gelaendegroesse/256),byte(gelaendegroesse%256))			
			// ... und konkatenieren des Geländeslices
			b = append(b,gel.Kodieren()...) 						
		}
	}
	return
}
	
	// Vor.: Der übergebene Slice b entspricht einem kodierten Spielfeld gleicher Größe.
	// Eff.: Die aufrufende Instanz hat nun genau diejenige Eigenschaft, sodass 'Kodieren ()' exakt
	//		 b ergeben würde. Alle vorherigen Eigenschaften des Spielfeldes hat sie nicht mehr.
func (s *data) Dekodieren (b []byte) {
	var aktindex int
	(*s).x=uint16(b[0])*256+uint16(b[1])
	aktindex=aktindex+2
	(*s).y=uint16(b[2])*256+uint16(b[3])
	aktindex=aktindex+2
	(*s).groesse=uint16(b[4])*256+uint16(b[5])
	aktindex=aktindex+2
	// Dekodieren der Anzahl an benötigter Bytes für Dateinamenstrings
	var stringlaenge uint8 = b[7]
	aktindex++
	// Dekodieren des Dateinamens
	for i:=6;i<int(stringlaenge)+6;i++ {
		(*s).dateiname=(*s).dateiname+string(b[i])
	}
	aktindex=aktindex+int(stringlaenge)
	// Dekodieren der Geländematrix
	for y:=uint16(0);y<(*s).y;y++ {
		for x:=uint16(0);x<(*s).x;x++ {
			var gelaendegroesse uint16
			gelaendegroesse= uint16(b[aktindex])*256+uint16(b[aktindex+1])
			aktindex=aktindex+2
			// Dekodieren des nächsten Geländes
			var dekodgel gelaende.Gelände 
			dekodgel=gelaende.New(x,y,"Wasser") 
			dekodgel.Dekodieren(b[aktindex:aktindex+int(gelaendegroesse)])
			(*s).gelaendematrix[y][x]=dekodgel
			aktindex=aktindex+int(gelaendegroesse)
		}
	}
}
